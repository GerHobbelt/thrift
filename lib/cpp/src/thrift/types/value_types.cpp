/**
 * Autogenerated by Thrift Compiler (2.5.4-upfluence)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "value_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace types { namespace value {


NullValue::~NullValue() throw() {
}


const char* NullValue::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t NullValue::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t NullValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NullValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("NullValue");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(NullValue &a, NullValue &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NullValue::NullValue(const NullValue& other0) {
  (void) other0;
}
NullValue& NullValue::operator=(const NullValue& other1) {
  (void) other1;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const NullValue& obj) {
  using apache::thrift::to_string;
  (void) obj;
  out << "NullValue(";
  out << ")";
  return out;
}


ListValue::~ListValue() throw() {
}


void ListValue::__set_values(const std::vector<Value> & val) {
  this->values = val;
}

const char* ListValue::ascii_fingerprint = "15B02FE500BAAA2F7672955D36328788";
const uint8_t ListValue::binary_fingerprint[16] = {0x15,0xB0,0x2F,0xE5,0x00,0xBA,0xAA,0x2F,0x76,0x72,0x95,0x5D,0x36,0x32,0x87,0x88};

uint32_t ListValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->values.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->values[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ListValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ListValue");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<Value> ::const_iterator _iter7;
    for (_iter7 = this->values.begin(); _iter7 != this->values.end(); ++_iter7)
    {
      xfer += (*_iter7).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ListValue &a, ListValue &b) {
  using ::std::swap;
  swap(a.values, b.values);
}

ListValue::ListValue(const ListValue& other8) {
  values = other8.values;
}
ListValue& ListValue::operator=(const ListValue& other9) {
  values = other9.values;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ListValue& obj) {
  using apache::thrift::to_string;
  out << "ListValue(";
  out << "values=" << to_string(obj.values);
  out << ")";
  return out;
}


MapEntry::~MapEntry() throw() {
}


void MapEntry::__set_key(const Value& val) {
  this->key = val;
}

void MapEntry::__set_value(const Value& val) {
  this->value = val;
}

const char* MapEntry::ascii_fingerprint = "899D86147A70AD678AA6AD12546F0F81";
const uint8_t MapEntry::binary_fingerprint[16] = {0x89,0x9D,0x86,0x14,0x7A,0x70,0xAD,0x67,0x8A,0xA6,0xAD,0x12,0x54,0x6F,0x0F,0x81};

uint32_t MapEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_key = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key.read(iprot);
          isset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MapEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("MapEntry");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(MapEntry &a, MapEntry &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
}

MapEntry::MapEntry(const MapEntry& other10) {
  key = other10.key;
  value = other10.value;
}
MapEntry& MapEntry::operator=(const MapEntry& other11) {
  key = other11.key;
  value = other11.value;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const MapEntry& obj) {
  using apache::thrift::to_string;
  out << "MapEntry(";
  out << "key=" << to_string(obj.key);
  out << ", " << "value=" << to_string(obj.value);
  out << ")";
  return out;
}


MapValue::~MapValue() throw() {
}


void MapValue::__set_entries(const std::vector<MapEntry> & val) {
  this->entries = val;
}

const char* MapValue::ascii_fingerprint = "CAC56EC2431562E5E990506462023138";
const uint8_t MapValue::binary_fingerprint[16] = {0xCA,0xC5,0x6E,0xC2,0x43,0x15,0x62,0xE5,0xE9,0x90,0x50,0x64,0x62,0x02,0x31,0x38};

uint32_t MapValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_entries = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->entries.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->entries[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_entries)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MapValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("MapValue");

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entries.size()));
    std::vector<MapEntry> ::const_iterator _iter17;
    for (_iter17 = this->entries.begin(); _iter17 != this->entries.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(MapValue &a, MapValue &b) {
  using ::std::swap;
  swap(a.entries, b.entries);
}

MapValue::MapValue(const MapValue& other18) {
  entries = other18.entries;
}
MapValue& MapValue::operator=(const MapValue& other19) {
  entries = other19.entries;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const MapValue& obj) {
  using apache::thrift::to_string;
  out << "MapValue(";
  out << "entries=" << to_string(obj.entries);
  out << ")";
  return out;
}


StructValue::~StructValue() throw() {
}


void StructValue::__set_fields(const std::map<std::string, Value> & val) {
  this->fields = val;
}

const char* StructValue::ascii_fingerprint = "2378FACF8F84D12EF3E8086302B4C487";
const uint8_t StructValue::binary_fingerprint[16] = {0x23,0x78,0xFA,0xCF,0x8F,0x84,0xD1,0x2E,0xF3,0xE8,0x08,0x63,0x02,0xB4,0xC4,0x87};

uint32_t StructValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_fields = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->fields.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _ktype21;
            ::apache::thrift::protocol::TType _vtype22;
            xfer += iprot->readMapBegin(_ktype21, _vtype22, _size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              std::string _key25;
              xfer += iprot->readString(_key25);
              Value& _val26 = this->fields[_key25];
              xfer += _val26.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          isset_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_fields)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t StructValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("StructValue");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::map<std::string, Value> ::const_iterator _iter27;
    for (_iter27 = this->fields.begin(); _iter27 != this->fields.end(); ++_iter27)
    {
      xfer += oprot->writeString(_iter27->first);
      xfer += _iter27->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(StructValue &a, StructValue &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
}

StructValue::StructValue(const StructValue& other28) {
  fields = other28.fields;
}
StructValue& StructValue::operator=(const StructValue& other29) {
  fields = other29.fields;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const StructValue& obj) {
  using apache::thrift::to_string;
  out << "StructValue(";
  out << "fields=" << to_string(obj.fields);
  out << ")";
  return out;
}


Value::~Value() throw() {
}


void Value::__set_null_value(const NullValue& val) {
  this->null_value = val;
}

void Value::__set_string_value(const std::string& val) {
  this->string_value = val;
}

void Value::__set_binary_value(const std::string& val) {
  this->binary_value = val;
}

void Value::__set_integer_value(const int64_t val) {
  this->integer_value = val;
}

void Value::__set_double_value(const double val) {
  this->double_value = val;
}

void Value::__set_bool_value(const bool val) {
  this->bool_value = val;
}

void Value::__set_list_value(const ListValue& val) {
  this->list_value = val;
}

void Value::__set_map_value(const MapValue& val) {
  this->map_value = val;
}

void Value::__set_struct_value(const StructValue& val) {
  this->struct_value = val;
}

const char* Value::ascii_fingerprint = "32DB10C593440BD63D470121CACCBC29";
const uint8_t Value::binary_fingerprint[16] = {0x32,0xDB,0x10,0xC5,0x93,0x44,0x0B,0xD6,0x3D,0x47,0x01,0x21,0xCA,0xCC,0xBC,0x29};

uint32_t Value::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->null_value.read(iprot);
          this->__isset.null_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->string_value);
          this->__isset.string_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->binary_value);
          this->__isset.binary_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->integer_value);
          this->__isset.integer_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->double_value);
          this->__isset.double_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bool_value);
          this->__isset.bool_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->list_value.read(iprot);
          this->__isset.list_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->map_value.read(iprot);
          this->__isset.map_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->struct_value.read(iprot);
          this->__isset.struct_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Value::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Value");

  xfer += oprot->writeFieldBegin("null_value", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->null_value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("string_value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->string_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("binary_value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->binary_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("integer_value", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->integer_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("double_value", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->double_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bool_value", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->bool_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("list_value", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->list_value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("map_value", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->map_value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("struct_value", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->struct_value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Value &a, Value &b) {
  using ::std::swap;
  swap(a.null_value, b.null_value);
  swap(a.string_value, b.string_value);
  swap(a.binary_value, b.binary_value);
  swap(a.integer_value, b.integer_value);
  swap(a.double_value, b.double_value);
  swap(a.bool_value, b.bool_value);
  swap(a.list_value, b.list_value);
  swap(a.map_value, b.map_value);
  swap(a.struct_value, b.struct_value);
  swap(a.__isset, b.__isset);
}

Value::Value(const Value& other30) {
  null_value = other30.null_value;
  string_value = other30.string_value;
  binary_value = other30.binary_value;
  integer_value = other30.integer_value;
  double_value = other30.double_value;
  bool_value = other30.bool_value;
  list_value = other30.list_value;
  map_value = other30.map_value;
  struct_value = other30.struct_value;
  __isset = other30.__isset;
}
Value& Value::operator=(const Value& other31) {
  null_value = other31.null_value;
  string_value = other31.string_value;
  binary_value = other31.binary_value;
  integer_value = other31.integer_value;
  double_value = other31.double_value;
  bool_value = other31.bool_value;
  list_value = other31.list_value;
  map_value = other31.map_value;
  struct_value = other31.struct_value;
  __isset = other31.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Value& obj) {
  using apache::thrift::to_string;
  out << "Value(";
  out << "null_value=" << to_string(obj.null_value);
  out << ", " << "string_value=" << to_string(obj.string_value);
  out << ", " << "binary_value=" << to_string(obj.binary_value);
  out << ", " << "integer_value=" << to_string(obj.integer_value);
  out << ", " << "double_value=" << to_string(obj.double_value);
  out << ", " << "bool_value=" << to_string(obj.bool_value);
  out << ", " << "list_value=" << to_string(obj.list_value);
  out << ", " << "map_value=" << to_string(obj.map_value);
  out << ", " << "struct_value=" << to_string(obj.struct_value);
  out << ")";
  return out;
}

}} // namespace
